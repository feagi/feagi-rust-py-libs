use pyo3::{pyclass, pymethods, PyResult};
use pyo3::prelude::*;
use pyo3::exceptions::PyValueError;
use feagi_data_structures::motor_cortical_units;
use feagi_data_structures::genomic::MotorCorticalUnit;
use feagi_data_structures::genomic::cortical_area::descriptors::CorticalGroupIndex;

use crate::feagi_data_structures::genomic::cortical_area::{PyCorticalID, PyFrameChangeHandling};

macro_rules! define_motor_cortical_units_enum {
    (
        MotorCorticalUnit {
            $(
                $(#[doc = $doc:expr])?
                $variant_name:ident => {
                    friendly_name: $friendly_name:expr,
                    snake_case_name: $snake_case_name:expr,
                    accepted_wrapped_io_data_type: $accepted_wrapped_io_data_type:expr,
                    cortical_id_unit_reference: $cortical_id_unit_reference:expr,
                    number_cortical_areas: $number_cortical_areas:expr,
                    cortical_type_parameters: {
                        $($param_name:ident: $param_type:ty),* $(,)?
                    },
                    cortical_area_properties: {
                        $($area_index:tt => ($cortical_area_type_expr:expr, relative_position: [$rel_x:expr, $rel_y:expr, $rel_z:expr], channel_dimensions_default: [$dim_default_x:expr, $dim_default_y:expr, $dim_default_z:expr], channel_dimensions_min: [$dim_min_x:expr, $dim_min_y:expr, $dim_min_z:expr], channel_dimensions_max: [$dim_max_x:expr, $dim_max_y:expr, $dim_max_z:expr])),* $(,)?
                    }
                }
            ),* $(,)?
        }
    ) => {

        #[pyclass]
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[pyo3(name = "MotorCorticalUnit")]
        pub enum PyMotorCorticalUnit {
            $(
                $(#[doc = $doc])?
                $variant_name,
            )*
        }

        impl From<PyMotorCorticalUnit> for MotorCorticalUnit {
            fn from(py_unit: PyMotorCorticalUnit) -> Self {
                match py_unit {
                    $(
                        PyMotorCorticalUnit::$variant_name => MotorCorticalUnit::$variant_name,
                    )*
                }
            }
        }

        impl From<MotorCorticalUnit> for PyMotorCorticalUnit {
            fn from(rust_unit: MotorCorticalUnit) -> Self {
                match rust_unit {
                    $(
                        MotorCorticalUnit::$variant_name => PyMotorCorticalUnit::$variant_name,
                    )*
                }
            }
        }

    };
}


// Generate the MotorCorticalUnit enum and all helper methods from the template
motor_cortical_units!(define_motor_cortical_units_enum);

// NOTE:
// `PyMotorCorticalUnit` is generated by `motor_cortical_units!(...)` above. We add
// explicit helper methods here for cortical-ID generation to avoid hardcoding
// base64 cortical IDs in Python controllers.
#[pymethods]
#[allow(non_snake_case)]
impl PyMotorCorticalUnit {
    /// Generate the output cortical IDs for Object Segmentation (`oseg`) for a given group.
    ///
    /// This uses the Rust `MotorCorticalUnit` template as the single source of truth.
    ///
    /// Args:
    ///     frame_change_handling: Absolute/Incremental handling.
    ///     group: Cortical group index (u8).
    ///
    /// Returns:
    ///     List of CorticalID objects (typically length 1 for `oseg`).
    #[staticmethod]
    pub fn object_segmentation_cortical_ids(
        frame_change_handling: PyFrameChangeHandling,
        group: u8,
    ) -> PyResult<Vec<PyCorticalID>> {
        let group: CorticalGroupIndex = group.into();
        let ids = MotorCorticalUnit::get_cortical_ids_array_for_object_segmentation(
            frame_change_handling.inner,
            group,
        );
        Ok(ids.into_iter().map(Into::into).collect())
    }

    /// Get the default per-channel dimensions for Object Segmentation (`oseg`).
    ///
    /// This returns the *per-channel* dimensions (channel_dimensions_default) from the
    /// canonical `MotorCorticalUnit::ObjectSegmentation` template.
    ///
    /// Returns:
    ///     (width, height, depth) as (u32, u32, u32)
    #[staticmethod]
    pub fn object_segmentation_default_channel_dimensions() -> PyResult<(u32, u32, u32)> {
        let topology = MotorCorticalUnit::ObjectSegmentation.get_unit_default_topology();
        let props = topology
            .get(&0)
            .ok_or_else(|| PyValueError::new_err("ObjectSegmentation missing area index 0"))?;
        let dims = props.channel_dimensions_default;
        Ok((dims[0], dims[1], dims[2]))
    }
}
