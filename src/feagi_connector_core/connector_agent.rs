use feagi_data_structures::genomic::cortical_area::descriptors::{CorticalChannelIndex, CorticalGroupIndex};
use feagi_data_structures::genomic::cortical_area::descriptors::CorticalChannelCount;
use std::sync::MutexGuard;
use pyo3::{pyclass, pymethods, PyResult};
use pyo3::prelude::*;
use feagi_data_structures::{sensor_cortical_units, FeagiDataError,};
use feagi_connector_core::caching::motor_device_cache::MotorDeviceCache;
use feagi_connector_core::caching::sensor_device_cache::SensorDeviceCache;
use feagi_connector_core::ConnectorAgent;
use crate::feagi_connector_core::data_types::descriptors::PyMiscDataDimensions;
use feagi_connector_core::data_pipeline::{PipelineStageProperties, PipelineStagePropertyIndex};
use feagi_connector_core::data_types::*;
use feagi_connector_core::data_types::descriptors::{ImageFrameProperties, MiscDataDimensions};
use feagi_connector_core::wrapped_io_data::WrappedIOData;
use crate::{create_pyclass_no_clone, __base_py_class_shared};
use crate::py_error::PyFeagiError;
use crate::feagi_connector_core::data_types::descriptors::*;
use crate::feagi_connector_core::data_pipeline::pipeline_stage_properties::{PyPipelineStageProperties};
use crate::feagi_connector_core::data_types::*;
use crate::feagi_connector_core::wrapped_io_data::{py_any_to_wrapped_io_data, wrapped_io_data_to_py_object};
use crate::feagi_data_serialization::PyFeagiByteContainer;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEVELOPER NOTE: THIS FILE HAS A LARGE REGION WHICH HAS AUTOGENERATED CODE BY BUILDRS WHICH MAY OVERWRITE YOUR CHANGES.
// TO TURN ON, THE BELOW COMMENT LINE MUST READ *EXACTLY* "BUILDRS_ON" (NO SPACES), CHANGE TO ANY OTHER VALUE TO DISABLE.
// FURTHER NOTE: WHEN OFF, SOME ERROR CHECKING OF THE IDE MAY BE NON=FUNCTIONAL!
//BUILDRS_OFF

type Pybool = bool; // ALL HAIL THE LOAD BEARING BOOLEAN

macro_rules! sensor_unit_functions {
    (
        SensoryCorticalUnit {
            $(
                $(#[doc = $doc:expr])?
                $cortical_type_key_name:ident => {
                    friendly_name: $friendly_name:expr,
                    snake_case_name: $snake_case_name:expr,
                    accepted_wrapped_io_data_type: $accepted_wrapped_io_data_type:ident,
                    cortical_id_unit_reference: $cortical_id_unit_reference:expr,
                    number_cortical_areas: $number_cortical_areas:expr,
                    cortical_type_parameters: {
                        $($param_name:ident: $param_type:ty),* $(,)?
                    },
                    cortical_area_properties: {
                        $($area_index:tt => ($cortical_area_type_expr:expr, relative_position: [$rel_x:expr, $rel_y:expr, $rel_z:expr], channel_dimensions_default: [$dim_default_x:expr, $dim_default_y:expr, $dim_default_z:expr], channel_dimensions_min: [$dim_min_x:expr, $dim_min_y:expr, $dim_min_z:expr], channel_dimensions_max: [$dim_max_x:expr, $dim_max_y:expr, $dim_max_z:expr])),* $(,)?
                    }
                }
            ),* $(,)?
        }
    ) =>
    {
        $(
            sensor_unit_functions!(@generate_functions
            $cortical_type_key_name,
            $snake_case_name,
            $accepted_wrapped_io_data_type
            );
        )*
    };


    //region Similar Functions
    // Helper macro to generate stage and other similar functions
    // "it's time for me to live up to my family name and face full life consequences"
    (@generate_similar_functions
        $cortical_type_key_name:ident,
        $snake_case_name:expr,
        $wrapped_data_type:ident
    ) => {
        ::paste::paste! {

            #[pymethods]
            impl PyConnectorAgent {

                pub fn [<sensor_ $snake_case_name _write>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: u32,
                    data: &Bound<'_, PyAny>,
                ) -> PyResult<()> {


                    let group: CorticalGroupIndex = group.into();
                    let channel_index: CorticalChannelIndex = channel_index.into();
                    let data: WrappedIOData = py_any_to_wrapped_io_data(py, data).map_err(PyFeagiError::from)?;

                    self.get_sensor_cache().[<$snake_case_name _write>](group, channel_index, data).map_err(PyFeagiError::from)?;
                    Ok(())
                }

                pub fn [<sensor_ $snake_case_name _read_postprocessed_cache_value>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: u32,
                ) -> PyResult<[<Py $wrapped_data_type>]> {

                    let group: CorticalGroupIndex = group.into();
                    let channel_index: CorticalChannelIndex = channel_index.into();

                    let expected_data = self.get_sensor_cache().[<$snake_case_name _read_postprocessed_cache_value>](group, channel_index).map_err(PyFeagiError::from)?;
                    Ok(expected_data.into())
                }

                /*
                pub fn [<sensor_ $snake_case_name _get_single_stage_properties>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: u32,
                    pipeline_stage_property_index: u32
                ) -> PyResult<PyObject>
                {
                    let group: CorticalGroupIndex = group.into();
                    let channel_index: CorticalChannelIndex = channel_index.into();
                    let pipeline_stage_property_index: PipelineStagePropertyIndex = pipeline_stage_property_index.into();

                    let boxed_stage = self.get_sensor_cache().[<$snake_case_name _get_single_stage_properties>](group, channel_index, pipeline_stage_property_index).map_err(PyFeagiError::from)?;
                    PyPipelineStageProperties::boxed_to_py(boxed_stage);
                }


                pub fn [<sensor_ $snake_case_name _get_all_stage_properties>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: u32,
                ) -> Result<Vec<Box<dyn PipelineStageProperties + Sync + Send>>, FeagiDataError>
                {
                    let group: CorticalGroupIndex = group.into();
                    let channel_index: CorticalChannelIndex = channel_index.into();

                    let boxed_stages = self.get_sensor_cache().[<$snake_case_name _get_all_stage_properties>](group, channel_index).map_err(PyFeagiError::from)?;

                    let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len()); // TODO we need a cleaner implementation
                    for boxed_stage in boxed_stages {{
                        output.push(boxed_stage.into());
                    }}
                    Ok(output)
                }

                 */

                /*

                pub fn [<sensor_ $snake_case_name _update_single_stage_properties>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: u32,
                    pipeline_stage_property_index: u32,
                    updating_property: PyObject // TODO this needs to be updated
                ) -> Result<(), FeagiDataError>
                {
                    let group: CorticalGroupIndex = group.into();
                    let channel_index: CorticalChannelIndex = channel_index.into();
                    let pipeline_stage_property_index: PipelineStagePropertyIndex = pipeline_stage_property_index.into();
                    let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

                    self.get_sensor_cache().[<$snake_case_name _update_single_stage_properties>](group, channel_index, pipeline_stage_property_index, updating_property).map_err(PyFeagiError::from)?;
                    Ok(())
                }

                 */

                /*

                pub fn [<sensor_ $snake_case_name _update_all_stage_properties>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: u32,
                    updated_pipeline_stage_properties: Vec<Box<dyn PipelineStageProperties + Sync + Send>>
                ) -> Result<(), FeagiDataError>
                {
                    const SENSOR_UNIT_TYPE: SensoryCorticalUnit = SensoryCorticalUnit::$cortical_type_key_name;
                    self.try_update_all_stage_properties(SENSOR_UNIT_TYPE, group, channel_index, updated_pipeline_stage_properties)?;
                    Ok(())
                }



                pub fn [<sensor_ $snake_case_name _replace_single_stage>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: CorticalChannelIndex,
                    pipeline_stage_property_index: PipelineStagePropertyIndex,
                    replacing_property: Box<dyn PipelineStageProperties + Sync + Send>
                ) -> Result<(), FeagiDataError>
                {
                    let group: CorticalGroupIndex = group.into();
                    let channel_index: CorticalChannelIndex = channel_index.into();
                    let pipeline_stage_property_index: PipelineStagePropertyIndex = pipeline_stage_property_index.into();
                    let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, replacing_property).map_err(PyFeagiError::from)?;

                    const SENSOR_UNIT_TYPE: SensoryCorticalUnit = SensoryCorticalUnit::$cortical_type_key_name;
                    self.try_replace_single_stage(SENSOR_UNIT_TYPE, group, channel_index, pipeline_stage_property_index, replacing_property)?;
                    Ok(())
                }

                pub fn [<sensor_ $snake_case_name _replace_all_stages>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: CorticalChannelIndex,
                    new_pipeline_stage_properties: Vec<Box<dyn PipelineStageProperties + Sync + Send>>
                ) -> Result<(), FeagiDataError>
                {
                    const SENSOR_UNIT_TYPE: SensoryCorticalUnit = SensoryCorticalUnit::$cortical_type_key_name;
                    self.try_replace_all_stages(SENSOR_UNIT_TYPE, group, channel_index, new_pipeline_stage_properties)?;
                    Ok(())
                }

                pub fn [<sensor_ $snake_case_name _removing_all_stages>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    channel_index: CorticalChannelIndex
                ) -> Result<(), FeagiDataError>
                {
                    const SENSOR_UNIT_TYPE: SensoryCorticalUnit = SensoryCorticalUnit::$cortical_type_key_name;
                    self.try_removing_all_stages(SENSOR_UNIT_TYPE, group, channel_index)?;
                    Ok(())
                }

                 */
             }
        }
    };
    //endregion


    // Arm for WrappedIOType::Boolean
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        Boolean
    ) => {


        ::paste::paste! {

            #[pymethods]
            impl PyConnectorAgent {
                pub fn [<sensor_ $snake_case_name _register>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    number_channels: u32,
                    ) -> PyResult<()>
                {
                    let group: CorticalGroupIndex = group.into();
                    let number_channels: CorticalChannelCount = number_channels.try_into().map_err(PyFeagiError::from)?;

                    self.get_sensor_cache().[<$snake_case_name _register>](group, number_channels).map_err(PyFeagiError::from)?;
                    Ok(())
                }
            }

        }
        // NOTE: Used the type Pybool at the to work. Fucking Cursed.
        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, bool);
    };

    // Arm for WrappedIOType::Percentage
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        Percentage
    ) => {
        ::paste::paste! {
            /*
            pub fn [<$snake_case_name _register>](
                &mut self,
                group: CorticalGroupIndex,
                number_channels: CorticalChannelCount,
                frame_change_handling: FrameChangeHandling,
                z_neuron_resolution: NeuronDepth,
                percentage_neuron_positioning: PercentageNeuronPositioning
                ) -> Result<(), FeagiDataError>
            {
                let cortical_id: CorticalID = SensoryCorticalUnit::[<get_cortical_ids_array_for_ $snake_case_name >](frame_change_handling, percentage_neuron_positioning, group)[0];
                let encoder: Box<dyn NeuronVoxelXYZPEncoder + Sync + Send> = {
                    match percentage_neuron_positioning { // TODO fix naming of exponential / fractional
                        PercentageNeuronPositioning::Linear => PercentageLinearNeuronVoxelXYZPEncoder::new_box(cortical_id, z_neuron_resolution, number_channels)?,
                        PercentageNeuronPositioning::Fractional => PercentageExponentialNeuronVoxelXYZPEncoder::new_box(cortical_id, z_neuron_resolution, number_channels)?,
                    }
                };

                let initial_val: WrappedIOData = WrappedIOData::Percentage(Percentage::new_zero());
                let default_pipeline: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = {
                    let mut output: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = Vec::new();
                    for _i in 0..*number_channels {
                        output.push( Vec::new()) // TODO properly implement clone so we dont need to do this
                    };
                    output
                };
                self.register(SensoryCorticalUnit::$sensory_unit, group, encoder, default_pipeline, initial_val)?;
                Ok(())
            }

             */
        }

        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, Percentage);
    };

    // Arm for WrappedIOType::Percentage_3D
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        Percentage_3D
    ) => {
        ::paste::paste! {
            /*
            pub fn [<$snake_case_name _register>](
                &mut self,
                group: CorticalGroupIndex,
                number_channels: CorticalChannelCount,
                frame_change_handling: FrameChangeHandling,
                z_neuron_resolution: NeuronDepth,
                percentage_neuron_positioning: PercentageNeuronPositioning
                ) -> Result<(), FeagiDataError>
            {
                let cortical_id: CorticalID = SensoryCorticalUnit::[<get_cortical_ids_array_for_ $snake_case_name >](frame_change_handling, percentage_neuron_positioning, group)[0];
                let encoder: Box<dyn NeuronVoxelXYZPEncoder + Sync + Send> = {
                    match percentage_neuron_positioning { // TODO fix naming of exponential / fractional
                        PercentageNeuronPositioning::Linear => Percentage3DLinearNeuronVoxelXYZPEncoder::new_box(cortical_id, z_neuron_resolution, number_channels)?,
                        PercentageNeuronPositioning::Fractional => Percentage3DExponentialNeuronVoxelXYZPEncoder::new_box(cortical_id, z_neuron_resolution, number_channels)?,
                    }
                };

                let initial_val: WrappedIOData = WrappedIOData::Percentage(Percentage::new_zero());
                let default_pipeline: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = {
                    let mut output: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = Vec::new();
                    for _i in 0..*number_channels {
                        output.push( Vec::new()) // TODO properly implement clone so we dont need to do this
                    };
                    output
                };
                self.register(SensoryCorticalUnit::$sensory_unit, group, encoder, default_pipeline, initial_val)?;
                Ok(())
            }

             */
        }

        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, Percentage3D);
    };

    // Arm for WrappedIOType::SignedPercentage_4D
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        SignedPercentage_4D
    ) => {
        ::paste::paste! {
            /*
            pub fn [<$snake_case_name _register>](
                &mut self,
                group: CorticalGroupIndex,
                number_channels: CorticalChannelCount,
                frame_change_handling: FrameChangeHandling,
                z_neuron_resolution: NeuronDepth,
                percentage_neuron_positioning: PercentageNeuronPositioning
                ) -> Result<(), FeagiDataError>
            {
                let cortical_id: CorticalID = SensoryCorticalUnit::[<get_cortical_ids_array_for_ $snake_case_name >](frame_change_handling, percentage_neuron_positioning, group)[0];
                let encoder: Box<dyn NeuronVoxelXYZPEncoder + Sync + Send> = {
                    match percentage_neuron_positioning { // TODO fix naming of exponential / fractional
                        PercentageNeuronPositioning::Linear => SignedPercentage4DLinearNeuronVoxelXYZPEncoder::new_box(cortical_id, z_neuron_resolution, number_channels)?,
                        PercentageNeuronPositioning::Fractional => SignedPercentage4DExponentialNeuronVoxelXYZPEncoder::new_box(cortical_id, z_neuron_resolution, number_channels)?,
                    }
                };

                let initial_val: WrappedIOData = WrappedIOData::Percentage(Percentage::new_zero());
                let default_pipeline: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = {
                    let mut output: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = Vec::new();
                    for _i in 0..*number_channels {
                        output.push( Vec::new()) // TODO properly implement clone so we dont need to do this
                    };
                    output
                };
                self.register(SensoryCorticalUnit::$sensory_unit, group, encoder, default_pipeline, initial_val)?;
                Ok(())
            }

             */
        }

        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, SignedPercentage4D);
    };

    // Arm for WrappedIOType::SegmentedImageFrame
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        SegmentedImageFrame
    ) => {
        ::paste::paste! {
            #[pymethods]
            impl PyConnectorAgent {
                pub fn [<sensor_ $snake_case_name _register>](
                    &mut self,
                    py: Python<'_>,
                    group: u8,
                    number_channels: u32,
                    frame_change_handling: &pyo3::Bound<PyFrameChangeHandling>,
                    input_image_properties: &pyo3::Bound<PyImageFrameProperties>,
                    segmented_image_properties: &pyo3::Bound<PySegmentedImageFrameProperties>,
                    initial_gaze: &pyo3::Bound<PyGazeProperties>,
                    ) -> PyResult<()>
                {
                    let group: CorticalGroupIndex = group.into();
                    let number_channels: CorticalChannelCount = number_channels.try_into().map_err(PyFeagiError::from)?;
                    let frame_change_handling: FrameChangeHandling = PyFrameChangeHandling::copy_out_from_bound::(frame_change_handling);
                    let input_image_properties: ImageFrameProperties = PyImageFrameProperties::copy_out_from_bound::(input_image_properties);
                    let segmented_image_properties: SegmentedImageFrameProperties = PySegmentedImageFrameProperties::copy_out_from_bound::(segmented_image_properties);

                    self.get_sensor_cache().[<$snake_case_name _register>](group, number_channels, frame_change_handling, input_image_properties, segmented_image_properties).map_err(PyFeagiError::from)?;
                    Ok(())
                }
            }
        }

        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, SegmentedImageFrame);
    };

    // Arm for WrappedIOType::MiscData
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        MiscData
    ) => {
        ::paste::paste! {
            /*
            pub fn [<$snake_case_name _register>](
                &mut self,
                group: CorticalGroupIndex,
                number_channels: CorticalChannelCount,
                frame_change_handling: FrameChangeHandling,
                misc_data_dimensions: MiscDataDimensions
                ) -> Result<(), FeagiDataError>
            {
                let cortical_id: CorticalID = SensoryCorticalUnit::[<get_cortical_ids_array_for_ $snake_case_name >](frame_change_handling, group)[0];
                let encoder: Box<dyn NeuronVoxelXYZPEncoder + Sync + Send> = MiscDataNeuronVoxelXYZPEncoder::new_box(cortical_id, misc_data_dimensions, number_channels)?;

                let initial_val: WrappedIOData = WrappedIOType::MiscData(Some(misc_data_dimensions)).create_blank_data_of_type()?;
                let default_pipeline: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = {
                    let mut output: Vec<Vec<Box<(dyn PipelineStageProperties + Send + Sync + 'static)>>> = Vec::new();
                    for _i in 0..*number_channels {
                        output.push( Vec::new()) // TODO properly implement clone so we dont need to do this
                    };
                    output
                };
                self.register(SensoryCorticalUnit::$sensory_unit, group, encoder, default_pipeline, initial_val)?;
                Ok(())
            }

             */
        }

        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, MiscData);
    };


    // Arm for WrappedIOType::ImageFrame
    (@generate_functions
        $sensory_unit:ident,
        $snake_case_name:expr,
        ImageFrame
    ) => {
        ::paste::paste! {
            /*
            pub fn [<$snake_case_name _register>](
                &mut self,
                group: CorticalGroupIndex,
                number_channels: CorticalChannelCount,
                frame_change_handling: FrameChangeHandling,
                image_properties: ImageFrameProperties,
                ) -> Result<(), FeagiDataError>
            {
                let cortical_id: CorticalID = SensoryCorticalUnit::[<get_cortical_ids_array_for_ $snake_case_name >](frame_change_handling, group)[0];
                let encoder: Box<dyn NeuronVoxelXYZPEncoder + Sync + Send> = CartesianPlaneNeuronVoxelXYZPEncoder::new_box(cortical_id, &image_properties, number_channels)?;

                let initial_val: WrappedIOData = WrappedIOType::ImageFrame(Some(image_properties)).create_blank_data_of_type()?;
                self.register(SensoryCorticalUnit::$sensory_unit, group, encoder, Vec::new(), initial_val)?;
                Ok(())
            }

             */
        }

        sensor_unit_functions!(@generate_similar_functions $sensory_unit, $snake_case_name, ImageFrame);
    };
}

create_pyclass_no_clone!(PyConnectorAgent, ConnectorAgent, "ConnectorAgent");

impl PyConnectorAgent {
    fn get_sensor_cache(&self) -> MutexGuard<SensorDeviceCache> {
        self.inner.get_sensor_cache()
    }

    fn get_motor_cache(&self) -> MutexGuard<MotorDeviceCache> {
        self.inner.get_motor_cache()
    }
}


#[pymethods]
impl PyConnectorAgent {
    #[new]
    pub fn new() -> Self {
        PyConnectorAgent {
            inner: ConnectorAgent::new(),
        }
    }
}

sensor_cortical_units!(sensor_unit_functions);


//region Motor Functions
//BUILDRS_MOTOR_DEVICE_START


//BUILDRS_MOTOR_DEVICE_END
//endregion

//region Sensor Functions
//BUILDRS_SENSOR_DEVICE_START

//BUILDRS_SENSOR_DEVICE_END
//endregion