use pyo3::{pyclass, pymethods, PyResult};
use pyo3::prelude::*;
use feagi_connector_core::IOCache;
use feagi_data_structures::genomic::descriptors::{CorticalChannelCount, CorticalChannelIndex, CorticalGroupIndex, NeuronDepth};
use feagi_data_structures::motor_definition;
use feagi_connector_core::data_pipeline::PipelineStagePropertyIndex;
use feagi_connector_core::data_types::*;
use crate::py_error::PyFeagiError;
use crate::feagi_connector_core::data::descriptors::{PyGazeProperties, PyImageFrameProperties, PySegmentedImageFrameProperties};
use crate::feagi_connector_core::data::*;
use crate::feagi_connector_core::data_pipeline::pipeline_stage_properties::{extract_pipeline_stage_properties_from_py, PyPipelineStageProperties};
use crate::feagi_connector_core::wrapped_io_data::py_object_to_wrapped_io_data;
use crate::feagi_data_structures::genomic::descriptors::{PyCorticalChannelCount, PyNeuronDepth, PyCorticalChannelIndex, PyCorticalGroupIndex, PyPipelineStagePropertyIndex};

// DEVELOPER NOTE: tHIS FILE HAS A LARGE REGION WHICH HAS AUTOGENERATED CODE BY BUILDRS WHICH MAY OVERWRITE YOUR CHANGES. DISABLE BUILDRS IF YOU ARE DOING WORK HERE!

#[pyclass]
#[pyo3(name = "IOCache")]
#[derive()]
pub struct PyIOCache {
    inner: IOCache
}

#[pymethods]
impl PyIOCache {

    #[new]
    pub fn new() -> Self {
        PyIOCache {
            inner: IOCache::new()
        }
    }

    //region AUTOGENERATED CODE

    //region Motor Functions
    //BUILDRS_MOTOR_DEVICE_START
    //region rotary_motor_absolute_linear

    pub fn motor_register_rotary_motor_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_rotary_motor_absolute_linear(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_rotary_motor_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_rotary_motor_absolute_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_rotary_motor_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_rotary_motor_absolute_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region rotary_motor_absolute_fractional

    pub fn motor_register_rotary_motor_absolute_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_rotary_motor_absolute_fractional(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_rotary_motor_absolute_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_rotary_motor_absolute_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_rotary_motor_absolute_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_rotary_motor_absolute_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region rotary_motor_incremental_linear

    pub fn motor_register_rotary_motor_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_rotary_motor_incremental_linear(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_rotary_motor_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_rotary_motor_incremental_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_rotary_motor_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_rotary_motor_incremental_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region rotary_motor_incremental_fractional

    pub fn motor_register_rotary_motor_incremental_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_rotary_motor_incremental_fractional(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_rotary_motor_incremental_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_rotary_motor_incremental_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_rotary_motor_incremental_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_rotary_motor_incremental_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region positional_servo_absolute_linear

    pub fn motor_register_positional_servo_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_positional_servo_absolute_linear(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_positional_servo_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_positional_servo_absolute_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_positional_servo_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_positional_servo_absolute_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region positional_servo_absolute_fractional

    pub fn motor_register_positional_servo_absolute_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_positional_servo_absolute_fractional(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_positional_servo_absolute_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_positional_servo_absolute_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_positional_servo_absolute_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_positional_servo_absolute_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region positional_servo_incremental_linear

    pub fn motor_register_positional_servo_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_positional_servo_incremental_linear(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_positional_servo_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_positional_servo_incremental_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_positional_servo_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_positional_servo_incremental_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region positional_servo_incremental_fractional

    pub fn motor_register_positional_servo_incremental_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_positional_servo_incremental_fractional(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_positional_servo_incremental_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_preprocessed_cached_value_positional_servo_incremental_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_positional_servo_incremental_fractional(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_try_read_postprocessed_cached_value_positional_servo_incremental_fractional(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region gaze_absolute_linear

    pub fn motor_register_gaze_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_gaze_absolute_linear(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_gaze_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage4D = self.inner.motor_try_read_preprocessed_cached_value_gaze_absolute_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_gaze_absolute_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage4D = self.inner.motor_try_read_postprocessed_cached_value_gaze_absolute_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //region gaze_incremental_linear

    pub fn motor_register_gaze_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_register_gaze_incremental_linear(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_try_read_preprocessed_cached_value_gaze_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage4D = self.inner.motor_try_read_preprocessed_cached_value_gaze_incremental_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_try_read_postprocessed_cached_value_gaze_incremental_linear(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage4D = self.inner.motor_try_read_postprocessed_cached_value_gaze_incremental_linear(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    //endregion

    //BUILDRS_MOTOR_DEVICE_END
    //endregion


    //endregion
    /*




    
    //region Sensors

    pub fn sensor_register_segmented_vision_absolute(&mut self, py: Python<'_>, group: PyObject,
                                                     number_of_channels: PyObject, input_image_properties: PyImageFrameProperties,
                                                     output_segment_properties: PySegmentedImageFrameProperties, gaze: PyGazeProperties) -> PyResult<()> {

        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;

        self.inner.sensor_register_segmented_vision_absolute(cortical_group_index,
                                                             number_of_channels, input_image_properties.into(),
                                                             output_segment_properties.into(), gaze.into()).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_write_segmented_vision_absolute(&mut self, py: Python<'_>, group: PyObject, channel: PyObject, data: PyObject) -> PyResult<()> {
        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let cortical_channel_index: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let wrapped_io_data = py_object_to_wrapped_io_data(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_write_segmented_vision_absolute(cortical_group_index, cortical_channel_index, &wrapped_io_data)
            .map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_update_stage_segmented_vision_absolute(&mut self, py: Python<'_>, group: PyObject, channel: PyObject,
                                                         pipeline_stage_property_index: PyObject, stage: PyObject) -> PyResult<()> {
        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let cortical_channel_index: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_property_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, pipeline_stage_property_index).map_err(PyFeagiError::from)?;
        
        // Extract PyObject to Py<PyPipelineStageProperties>
        let stage_py: Py<PyPipelineStageProperties> = stage.extract(py)?;
        let pipeline_stage_properties = extract_pipeline_stage_properties_from_py(py, stage_py).map_err(PyFeagiError::from)?;

        self.inner.sensor_update_stage_segmented_vision_absolute(cortical_group_index, cortical_channel_index,
                                                                 stage_property_index, pipeline_stage_properties)
            .map_err(PyFeagiError::from)?;
        Ok(())
    }



    pub fn sensor_get_bytes(&mut self, py: Python<'_>) -> PyResult<Vec<u8>> {
        let bytes = self.inner.sensor_get_bytes().map_err(PyFeagiError::from)?;
        Ok(bytes.to_vec())

    }

    //endregion


    //region Motors

    pub fn motor_send_bytes(&mut self, py: Python<'_>, bytes: Vec<u8>) -> PyResult<()> {
        self.inner.motor_send_bytes(&bytes).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */


    //region Motors


    //region Gaze

    /*

    pub fn motor_add_callback_gaze_absolute(&mut self, py: Python<'_>, group: PyObject, channel: PyObject, callback: PyObject) -> PyResult<PyFeagiSignalIndex> {
        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let cortical_channel_index: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        // Create a closure that calls the Python callback
        let py_callback = callback.clone();
        let rust_callback = move |_data: &()| {
            Python::with_gil(|py| {
                if let Err(e) = py_callback.call0(py) {
                    eprintln!("Error calling Python callback: {:?}", e);
                }
            });
        };

        let signal_index: FeagiSignalIndex = self.inner.motor_add_callback_gaze_absolute(cortical_group_index, cortical_channel_index, rust_callback)
            .map_err(PyFeagiError::from)?;
        
        Ok(PyFeagiSignalIndex::from(signal_index))
    }

     */


    //endregion


}
