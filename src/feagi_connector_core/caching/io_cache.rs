use crate::feagi_connector_core::data::descriptors::PyMiscDataDimensions;
use pyo3::{pyclass, pymethods, PyResult};
use pyo3::prelude::*;
use feagi_connector_core::IOCache;
use feagi_data_structures::genomic::descriptors::{CorticalChannelCount, CorticalChannelIndex, CorticalGroupIndex, NeuronDepth};
use feagi_data_structures::motor_definition;
use feagi_connector_core::data_pipeline::{PipelineStageProperties, PipelineStagePropertyIndex};
use feagi_connector_core::data_types::*;
use feagi_connector_core::data_types::descriptors::{ImageFrameProperties, MiscDataDimensions};
use feagi_connector_core::wrapped_io_data::WrappedIOData;
use crate::py_error::PyFeagiError;
use crate::feagi_connector_core::data::descriptors::*;
use crate::feagi_connector_core::data::*;
use crate::feagi_connector_core::data_pipeline::pipeline_stage_properties::{PyPipelineStageProperties};
use crate::feagi_connector_core::wrapped_io_data::py_object_to_wrapped_io_data;
use crate::feagi_data_serialization::PyFeagiByteContainer;
use crate::feagi_data_structures::genomic::descriptors::{PyCorticalChannelCount, PyNeuronDepth, PyCorticalChannelIndex, PyCorticalGroupIndex, PyPipelineStagePropertyIndex};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEVELOPER NOTE: THIS FILE HAS A LARGE REGION WHICH HAS AUTOGENERATED CODE BY BUILDRS WHICH MAY OVERWRITE YOUR CHANGES.
// TO TURN ON, THE BELOW COMMENT LINE MUST READ *EXACTLY* "BUILDRS_ON" (NO SPACES), CHANGE TO ANY OTHER VALUE TO DISABLE.
// FURTHER NOTE: WHEN OFF, SOME ERROR CHECKING OF THE IDE MAY BE NON=FUNCTIONAL!
//BUILDRS_ON
 
#[pyclass]
#[pyo3(name = "IOCache")]
#[derive()]
pub struct PyIOCache {
    inner: IOCache
}

#[pymethods]
impl PyIOCache {

    #[new]
    pub fn new() -> Self {
        PyIOCache {
            inner: IOCache::new()
        }
    }

    //region AUTOGENERATED CODE

    //region Motor Functions
    //BUILDRS_MOTOR_DEVICE_START
    //region rotary_motor_absolute_linear

    pub fn motor_rotary_motor_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_linear_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_absolute_linear_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_rotary_motor_absolute_linear_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_absolute_linear_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_rotary_motor_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_rotary_motor_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_rotary_motor_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_rotary_motor_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_rotary_motor_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_linear_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_rotary_motor_absolute_linear_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region rotary_motor_absolute_fractional

    pub fn motor_rotary_motor_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_absolute_fractional_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_absolute_fractional_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_rotary_motor_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_rotary_motor_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_rotary_motor_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_rotary_motor_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_absolute_fractional_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_rotary_motor_absolute_fractional_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region rotary_motor_incremental_linear

    pub fn motor_rotary_motor_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_linear_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_incremental_linear_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_rotary_motor_incremental_linear_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_incremental_linear_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_rotary_motor_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_rotary_motor_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_rotary_motor_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_rotary_motor_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_rotary_motor_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_linear_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_rotary_motor_incremental_linear_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region rotary_motor_incremental_fractional

    pub fn motor_rotary_motor_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_incremental_fractional_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_rotary_motor_incremental_fractional_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_rotary_motor_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_rotary_motor_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_rotary_motor_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_rotary_motor_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_rotary_motor_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_rotary_motor_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_rotary_motor_incremental_fractional_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_rotary_motor_incremental_fractional_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region positional_servo_absolute_linear

    pub fn motor_positional_servo_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_linear_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_absolute_linear_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_positional_servo_absolute_linear_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_absolute_linear_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_positional_servo_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_positional_servo_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_positional_servo_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_positional_servo_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_positional_servo_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_linear_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_positional_servo_absolute_linear_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region positional_servo_absolute_fractional

    pub fn motor_positional_servo_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_fractional_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_absolute_fractional_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_positional_servo_absolute_fractional_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_absolute_fractional_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_positional_servo_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_positional_servo_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_positional_servo_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_positional_servo_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_positional_servo_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_absolute_fractional_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_positional_servo_absolute_fractional_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region positional_servo_incremental_linear

    pub fn motor_positional_servo_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_linear_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_incremental_linear_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_positional_servo_incremental_linear_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_incremental_linear_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_positional_servo_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_positional_servo_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_positional_servo_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_positional_servo_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_positional_servo_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_linear_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_positional_servo_incremental_linear_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region positional_servo_incremental_fractional

    pub fn motor_positional_servo_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_fractional_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_incremental_fractional_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_positional_servo_incremental_fractional_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.motor_positional_servo_incremental_fractional_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_positional_servo_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_positional_servo_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_positional_servo_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_positional_servo_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_positional_servo_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_positional_servo_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_positional_servo_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_positional_servo_incremental_fractional_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_positional_servo_incremental_fractional_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region gaze_absolute_linear

    pub fn motor_gaze_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_gaze_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_absolute_linear_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage4D = self.inner.motor_gaze_absolute_linear_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_gaze_absolute_linear_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage4D = self.inner.motor_gaze_absolute_linear_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_gaze_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_gaze_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_gaze_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_gaze_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_gaze_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_gaze_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_gaze_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_gaze_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_gaze_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_absolute_linear_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_gaze_absolute_linear_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region gaze_incremental_linear

    pub fn motor_gaze_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.motor_gaze_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_incremental_linear_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage4D = self.inner.motor_gaze_incremental_linear_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_gaze_incremental_linear_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage4D>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage4D = self.inner.motor_gaze_incremental_linear_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_gaze_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_gaze_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_gaze_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_gaze_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_gaze_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_gaze_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_gaze_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_gaze_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_gaze_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_gaze_incremental_linear_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_gaze_incremental_linear_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }
    */

    //endregion

    //region miscellaneous_absolute

    pub fn motor_miscellaneous_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        misc_dimensions: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let misc_dimensions: MiscDataDimensions = PyMiscDataDimensions::try_get_from_py_object(py, misc_dimensions).map_err(PyFeagiError::from)?;

        self.inner.motor_miscellaneous_absolute_try_register(group, number_of_channels, misc_dimensions).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_absolute_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyMiscData>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: MiscData = self.inner.motor_miscellaneous_absolute_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_miscellaneous_absolute_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyMiscData>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: MiscData = self.inner.motor_miscellaneous_absolute_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_miscellaneous_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_miscellaneous_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_miscellaneous_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_miscellaneous_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_miscellaneous_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_miscellaneous_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_miscellaneous_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_miscellaneous_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_miscellaneous_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_absolute_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_miscellaneous_absolute_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }

    */

    //endregion

    //region miscellaneous_incremental

    pub fn motor_miscellaneous_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        misc_dimensions: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let misc_dimensions: MiscDataDimensions = PyMiscDataDimensions::try_get_from_py_object(py, misc_dimensions).map_err(PyFeagiError::from)?;

        self.inner.motor_miscellaneous_incremental_try_register(group, number_of_channels, misc_dimensions).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_incremental_try_read_preprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyMiscData>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: MiscData = self.inner.motor_miscellaneous_incremental_try_read_preprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    pub fn motor_miscellaneous_incremental_try_read_postprocessed_cached_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyMiscData>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: MiscData = self.inner.motor_miscellaneous_incremental_try_read_postprocessed_cached_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn motor_miscellaneous_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.motor_miscellaneous_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn motor_miscellaneous_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.motor_miscellaneous_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn motor_miscellaneous_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.motor_miscellaneous_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_miscellaneous_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.motor_miscellaneous_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.motor_miscellaneous_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn motor_miscellaneous_incremental_try_register_motor_callback(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        callback: PyObject,
    ) -> PyResult<PyFeagiSignalIndex>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        
        // Note: Callback handling would need special implementation for Python callbacks
        // This is a placeholder that would need proper PyO3 callback wrapping
        let signal_index = self.inner.motor_miscellaneous_incremental_try_register_motor_callback(
            group,
            channel,
            |_| { /* Python callback wrapper */ }
        ).map_err(PyFeagiError::from)?;
        
        Ok(signal_index.into())
    }

    */

    //endregion

    //BUILDRS_MOTOR_DEVICE_END
    //endregion

    //region Sensor Functions
    //BUILDRS_SENSOR_DEVICE_START
    //region infrared_absolute_linear

    pub fn sensor_infrared_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_absolute_fractional

    pub fn sensor_infrared_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_incremental_linear

    pub fn sensor_infrared_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_incremental_fractional

    pub fn sensor_infrared_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_inverted_absolute_linear

    pub fn sensor_infrared_inverted_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_inverted_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_inverted_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_inverted_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_inverted_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_inverted_absolute_fractional

    pub fn sensor_infrared_inverted_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_inverted_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_inverted_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_inverted_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_inverted_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_inverted_incremental_linear

    pub fn sensor_infrared_inverted_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_inverted_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_inverted_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_inverted_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_inverted_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region infrared_inverted_incremental_fractional

    pub fn sensor_infrared_inverted_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_infrared_inverted_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_infrared_inverted_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_infrared_inverted_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_infrared_inverted_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_infrared_inverted_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_infrared_inverted_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_infrared_inverted_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_digital_absolute_linear

    pub fn sensor_gpio_digital_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_digital_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_digital_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_digital_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_digital_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_digital_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_digital_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_digital_absolute_fractional

    pub fn sensor_gpio_digital_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_digital_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_digital_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_digital_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_digital_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_digital_incremental_linear

    pub fn sensor_gpio_digital_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_digital_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_digital_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_digital_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_digital_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_digital_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_digital_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_digital_incremental_fractional

    pub fn sensor_gpio_digital_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_digital_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_digital_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_digital_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_digital_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_digital_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_digital_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_digital_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region proximity_absolute_linear

    pub fn sensor_proximity_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_proximity_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_proximity_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_proximity_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_proximity_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_proximity_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_proximity_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region proximity_absolute_fractional

    pub fn sensor_proximity_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_proximity_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_proximity_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_proximity_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_proximity_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_proximity_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_proximity_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region proximity_incremental_linear

    pub fn sensor_proximity_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_proximity_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_proximity_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_proximity_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_proximity_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_proximity_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_proximity_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region proximity_incremental_fractional

    pub fn sensor_proximity_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_proximity_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_proximity_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_proximity_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_proximity_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_proximity_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_proximity_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_proximity_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_proximity_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_proximity_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region shock_absolute_linear

    pub fn sensor_shock_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_shock_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_shock_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_shock_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_shock_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_shock_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_shock_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region shock_absolute_fractional

    pub fn sensor_shock_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_shock_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_shock_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_shock_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_shock_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_shock_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_shock_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region shock_incremental_linear

    pub fn sensor_shock_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_shock_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_shock_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_shock_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_shock_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_shock_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_shock_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region shock_incremental_fractional

    pub fn sensor_shock_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_shock_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_shock_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_shock_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_shock_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_shock_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_shock_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_shock_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_shock_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_shock_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region battery_gauge_absolute_linear

    pub fn sensor_battery_gauge_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_battery_gauge_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_battery_gauge_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_battery_gauge_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_battery_gauge_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_battery_gauge_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_battery_gauge_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region battery_gauge_absolute_fractional

    pub fn sensor_battery_gauge_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_battery_gauge_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_battery_gauge_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_battery_gauge_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_battery_gauge_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region battery_gauge_incremental_linear

    pub fn sensor_battery_gauge_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_battery_gauge_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_battery_gauge_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_battery_gauge_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_battery_gauge_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_battery_gauge_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_battery_gauge_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region battery_gauge_incremental_fractional

    pub fn sensor_battery_gauge_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_battery_gauge_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_battery_gauge_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_battery_gauge_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_battery_gauge_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_battery_gauge_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_battery_gauge_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_battery_gauge_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_analog_absolute_linear

    pub fn sensor_gpio_analog_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_analog_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_analog_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_analog_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_analog_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_analog_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_analog_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_analog_absolute_fractional

    pub fn sensor_gpio_analog_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_analog_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_analog_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_analog_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_analog_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_analog_incremental_linear

    pub fn sensor_gpio_analog_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_analog_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_analog_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_analog_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_analog_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_analog_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_analog_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region gpio_analog_incremental_fractional

    pub fn sensor_gpio_analog_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: Percentage = PyPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: Percentage = self.inner.sensor_gpio_analog_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_gpio_analog_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_gpio_analog_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_gpio_analog_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_gpio_analog_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_gpio_analog_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_gpio_analog_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_position_absolute_linear

    pub fn sensor_servo_position_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_position_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_position_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_position_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_position_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_position_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_position_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_position_absolute_fractional

    pub fn sensor_servo_position_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_position_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_position_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_position_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_position_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_position_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_position_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_position_incremental_linear

    pub fn sensor_servo_position_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_position_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_position_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_position_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_position_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_position_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_position_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_position_incremental_fractional

    pub fn sensor_servo_position_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_position_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_position_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_position_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_position_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_position_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_position_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_position_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_position_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_position_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_motion_absolute_linear

    pub fn sensor_servo_motion_absolute_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_motion_absolute_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_motion_absolute_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_motion_absolute_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_motion_absolute_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_motion_absolute_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_motion_absolute_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_absolute_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_absolute_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_motion_absolute_fractional

    pub fn sensor_servo_motion_absolute_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_motion_absolute_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_motion_absolute_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_motion_absolute_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_motion_absolute_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_motion_absolute_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_motion_absolute_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_absolute_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_absolute_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_absolute_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_absolute_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_motion_incremental_linear

    pub fn sensor_servo_motion_incremental_linear_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_linear_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_linear_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_linear_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_linear_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_motion_incremental_linear_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_motion_incremental_linear_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_motion_incremental_linear_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_motion_incremental_linear_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_motion_incremental_linear_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_motion_incremental_linear_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_linear_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_linear_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_incremental_linear_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_linear_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_linear_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_linear_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_incremental_linear_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region servo_motion_incremental_fractional

    pub fn sensor_servo_motion_incremental_fractional_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        z_neuron_depth: PyObject
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let z_neuron_depth: NeuronDepth = PyNeuronDepth::try_get_from_py_object(py, z_neuron_depth).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_fractional_try_register(group, number_of_channels, z_neuron_depth).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_fractional_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: SignedPercentage = PySignedPercentage::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_fractional_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_fractional_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PySignedPercentage>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: SignedPercentage = self.inner.sensor_servo_motion_incremental_fractional_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_servo_motion_incremental_fractional_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_servo_motion_incremental_fractional_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_servo_motion_incremental_fractional_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_servo_motion_incremental_fractional_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_servo_motion_incremental_fractional_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_fractional_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_fractional_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_incremental_fractional_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_fractional_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_servo_motion_incremental_fractional_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_servo_motion_incremental_fractional_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_servo_motion_incremental_fractional_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region miscellaneous_absolute

    pub fn sensor_miscellaneous_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        misc_dimensions: PyMiscDataDimensions,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let misc_dimensions: MiscDataDimensions = misc_dimensions.into();

        self.inner.sensor_miscellaneous_absolute_try_register(group, number_of_channels, misc_dimensions).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: MiscData = PyMiscData::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_miscellaneous_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyMiscData>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: MiscData = self.inner.sensor_miscellaneous_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_miscellaneous_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_miscellaneous_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_miscellaneous_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_miscellaneous_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_miscellaneous_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_miscellaneous_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_miscellaneous_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_miscellaneous_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_miscellaneous_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */
    //endregion

    //region miscellaneous_incremental

    pub fn sensor_miscellaneous_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        misc_dimensions: PyMiscDataDimensions,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let misc_dimensions: MiscDataDimensions = misc_dimensions.into();

        self.inner.sensor_miscellaneous_incremental_try_register(group, number_of_channels, misc_dimensions).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: MiscData = PyMiscData::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_miscellaneous_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyMiscData>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: MiscData = self.inner.sensor_miscellaneous_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_miscellaneous_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_miscellaneous_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_miscellaneous_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_miscellaneous_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_miscellaneous_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_miscellaneous_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_miscellaneous_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_miscellaneous_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_miscellaneous_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_miscellaneous_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */
    //endregion

    //region image_camera_center_absolute

    pub fn sensor_image_camera_center_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_center_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_center_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_center_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_center_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_center_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_center_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_center_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_center_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_center_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_center_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_center_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_center_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_center_incremental

    pub fn sensor_image_camera_center_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_center_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_center_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_center_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_center_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_center_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_center_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_center_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_center_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_center_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_center_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_center_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_center_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_center_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_top_left_absolute

    pub fn sensor_image_camera_top_left_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_top_left_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_left_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_top_left_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_top_left_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_top_left_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_top_left_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_top_left_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_top_left_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_left_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_left_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_left_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_left_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_top_left_incremental

    pub fn sensor_image_camera_top_left_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_top_left_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_left_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_top_left_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_top_left_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_top_left_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_top_left_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_top_left_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_top_left_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_left_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_left_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_left_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_left_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_left_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_top_middle_absolute

    pub fn sensor_image_camera_top_middle_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_top_middle_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_middle_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_top_middle_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_top_middle_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_top_middle_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_top_middle_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_top_middle_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_top_middle_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_middle_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_middle_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_middle_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_middle_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_top_middle_incremental

    pub fn sensor_image_camera_top_middle_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_top_middle_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_middle_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_top_middle_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_top_middle_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_top_middle_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_top_middle_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_top_middle_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_top_middle_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_middle_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_middle_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_middle_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_middle_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_middle_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_top_right_absolute

    pub fn sensor_image_camera_top_right_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_top_right_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_right_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_top_right_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_top_right_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_top_right_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_top_right_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_top_right_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_top_right_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_right_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_right_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_right_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_right_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_top_right_incremental

    pub fn sensor_image_camera_top_right_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_top_right_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_right_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_top_right_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_top_right_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_top_right_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_top_right_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_top_right_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_top_right_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_right_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_right_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_top_right_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_top_right_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_top_right_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_middle_left_absolute

    pub fn sensor_image_camera_middle_left_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_middle_left_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_left_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_middle_left_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_middle_left_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_middle_left_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_middle_left_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_middle_left_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_middle_left_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_left_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_left_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_left_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_left_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_middle_left_incremental

    pub fn sensor_image_camera_middle_left_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_middle_left_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_left_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_middle_left_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_middle_left_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_middle_left_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_middle_left_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_middle_left_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_middle_left_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_left_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_left_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_left_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_left_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_left_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_middle_right_absolute

    pub fn sensor_image_camera_middle_right_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_middle_right_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_right_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_middle_right_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_middle_right_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_middle_right_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_middle_right_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_middle_right_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_middle_right_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_right_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_right_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_right_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_right_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_middle_right_incremental

    pub fn sensor_image_camera_middle_right_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_middle_right_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_right_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_middle_right_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_middle_right_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_middle_right_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_middle_right_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_middle_right_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_middle_right_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_right_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_right_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_middle_right_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_middle_right_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_middle_right_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_bottom_left_absolute

    pub fn sensor_image_camera_bottom_left_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_bottom_left_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_left_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_bottom_left_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_bottom_left_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_bottom_left_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_bottom_left_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_left_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_left_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_left_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_left_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_bottom_left_incremental

    pub fn sensor_image_camera_bottom_left_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_bottom_left_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_left_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_bottom_left_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_bottom_left_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_bottom_left_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_bottom_left_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_left_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_left_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_left_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_left_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_left_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_bottom_middle_absolute

    pub fn sensor_image_camera_bottom_middle_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_bottom_middle_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_middle_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_bottom_middle_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_bottom_middle_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_bottom_middle_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_bottom_middle_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_middle_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_middle_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_middle_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_middle_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_bottom_middle_incremental

    pub fn sensor_image_camera_bottom_middle_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_bottom_middle_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_middle_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_bottom_middle_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_bottom_middle_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_bottom_middle_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_bottom_middle_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_middle_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_middle_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_middle_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_middle_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_middle_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_bottom_right_absolute

    pub fn sensor_image_camera_bottom_right_absolute_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_bottom_right_absolute_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_right_absolute_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_bottom_right_absolute_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_bottom_right_absolute_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_bottom_right_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_bottom_right_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_right_absolute_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_right_absolute_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_right_absolute_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_absolute_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_right_absolute_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //region image_camera_bottom_right_incremental

    pub fn sensor_image_camera_bottom_right_incremental_try_register(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        number_of_channels: PyObject,
        image_properties: PyImageFrameProperties,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;
        let image_properties: ImageFrameProperties = image_properties.into();

        self.inner.sensor_image_camera_bottom_right_incremental_try_register(group, number_of_channels, image_properties).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_write(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        data: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let data: ImageFrame = PyImageFrame::try_get_from_py_object(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_right_incremental_try_write(group, channel, data).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_read_postprocessed_cache_value(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<PyImageFrame>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let unwrapped: ImageFrame = self.inner.sensor_image_camera_bottom_right_incremental_try_read_postprocessed_cache_value(group, channel).map_err(PyFeagiError::from)?;
        Ok(unwrapped.into())
    }

    /*
    pub fn sensor_image_camera_bottom_right_incremental_try_get_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
    ) -> PyResult<PyPipelineStageProperties>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_image_camera_bottom_right_incremental_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        Ok(boxed_stage.into())
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_get_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
    ) -> PyResult<Vec<PyPipelineStageProperties>>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let boxed_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_image_camera_bottom_right_incremental_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut output: Vec<PyPipelineStageProperties> = Vec::with_capacity(boxed_stages.len());
        for boxed_stage in boxed_stages {
            output.push(boxed_stage.into());
        }

        Ok(output)
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_update_single_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        updating_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let updating_property: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, updating_property).map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_right_incremental_try_update_single_stage_properties(group, channel, stage_index, updating_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_update_all_stage_properties(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        updated_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(updated_pipeline_stage_properties.len());
        for py_stage in updated_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_right_incremental_try_update_all_stage_properties(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_replace_single_stage(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        stage_index: PyObject,
        replacing_property: PyObject,
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;
        let replacing_property: Box<dyn PipelineStageProperties + Sync + Send> = replacing_property.into().map_err(PyFeagiError::from)?;

        self.inner.sensor_image_camera_bottom_right_incremental_try_replace_single_stage(group, channel, stage_index, replacing_property).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_image_camera_bottom_right_incremental_try_replace_all_stages(
        &mut self,
        py: Python<'_>,
        group: PyObject,
        channel: PyObject,
        new_pipeline_stage_properties: Vec<PyObject>
    ) -> PyResult<()>
    {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let mut stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = Vec::with_capacity(new_pipeline_stage_properties.len());
        for py_stage in new_pipeline_stage_properties {
            let stage: Box<dyn PipelineStageProperties + Sync + Send> = extract_pipeline_stage_properties_from_py(py, py_stage).map_err(PyFeagiError::from)?;
            stages.push(stage);
        }

        self.inner.sensor_image_camera_bottom_right_incremental_try_replace_all_stages(group, channel, stages).map_err(PyFeagiError::from)?;
        Ok(())
    }
    */

    //endregion

    //BUILDRS_SENSOR_DEVICE_END
    //endregion

    //endregion


    //region Sensors

    pub fn sensors_encode_cached_data_to_bytes(&mut self) -> PyResult<()> {
        self.inner.sensor_encode_data_to_bytes(0).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_get_byte_container(&mut self, py: Python<'_>) -> PyResult<PyFeagiByteContainer> {
        let byte_container = self.inner.sensor_copy_feagi_byte_container();
        Ok(byte_container.into())
    }

    //region Segmented Vision

    pub fn sensor_segmented_vision_absolute_try_register(&mut self, py: Python<'_>, group: PyObject,
                                                     number_of_channels: PyObject, input_image_properties: PyImageFrameProperties,
                                                     output_segment_properties: PySegmentedImageFrameProperties, gaze: PyGazeProperties) -> PyResult<()> {

        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let number_of_channels: CorticalChannelCount = PyCorticalChannelCount::try_get_from_py_object(py, number_of_channels).map_err(PyFeagiError::from)?;

        self.inner.sensor_segmented_vision_absolute_try_register(cortical_group_index,
                                                             number_of_channels, input_image_properties.into(),
                                                             output_segment_properties.into(), gaze.into()).map_err(PyFeagiError::from)?;
        Ok(())
    }

    pub fn sensor_segmented_vision_absolute_try_write(&mut self, py: Python<'_>, group: PyObject, channel: PyObject, data: PyObject) -> PyResult<()> {
        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let cortical_channel_index: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let wrapped_io_data = py_object_to_wrapped_io_data(py, data).map_err(PyFeagiError::from)?;

        self.inner.sensor_segmented_vision_absolute_try_write(cortical_group_index, cortical_channel_index, &wrapped_io_data)
            .map_err(PyFeagiError::from)?;
        Ok(())
    }


    pub fn sensor_segmented_vision_absolute_try_read_post_processed_cache_value(&mut self, py: Python<'_>, group: PyObject, channel: PyObject) -> PyResult<PySegmentedImageFrame> {
        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let cortical_channel_index: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let segmented_image_frame = self.inner.sensor_segmented_vision_absolute_try_read_postprocessed_cache_value(cortical_group_index, cortical_channel_index).map_err(PyFeagiError::from)?;
        Ok(segmented_image_frame.into())
    }



    pub fn sensor_segmented_vision_absolute_try_get_single_stage_properties(&mut self, py: Python<'_>, group: PyObject, channel: PyObject, stage_index: PyObject) -> PyResult<PyObject> {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        let boxed_stage: Box<dyn PipelineStageProperties + Sync + Send> = self.inner.sensor_segmented_vision_absolute_try_get_single_stage_properties(group, channel, stage_index).map_err(PyFeagiError::from)?;
        let py_inherited_pipeline_properties = PyPipelineStageProperties::boxed_to_py(py, boxed_stage)?;
        Ok(py_inherited_pipeline_properties)
    }

    pub fn sensor_segmented_vision_absolute_try_get_all_stage_properties(&mut self, py: Python<'_>, group: PyObject, channel: PyObject) -> PyResult<Vec<PyObject>> {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;

        let box_stages: Vec<Box<dyn PipelineStageProperties + Sync + Send>> = self.inner.sensor_segmented_vision_absolute_try_get_all_stage_properties(group, channel).map_err(PyFeagiError::from)?;
        let mut py_output_stages: Vec<PyObject> = Vec::with_capacity(box_stages.len());
        for boxed_stage in &box_stages {
            let py_property = PyPipelineStageProperties::boxed_to_py(py, boxed_stage.clone_box())?;
            py_output_stages.push(py_property);
        }
        Ok(py_output_stages)
    }

    pub fn sensor_segmented_vision_absolute_try_update_single_stage_properties(&mut self, py: Python<'_>, group: PyObject, channel: PyObject, stage_index: PyObject, new_stage: PyPipelineStageProperties) -> PyResult<()> {
        let group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, stage_index).map_err(PyFeagiError::from)?;

        self.inner.sensor_segmented_vision_absolute_try_update_single_stage_properties(group, channel, stage_index, new_stage.into()).map_err(PyFeagiError::from)?;

        Ok(())
    }

    /*
    pub fn sensor_update_stage_segmented_vision_absolute(&mut self, py: Python<'_>, group: PyObject, channel: PyObject,
                                                         pipeline_stage_property_index: PyObject, stage: PyObject) -> PyResult<()> {
        let cortical_group_index: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, group).map_err(PyFeagiError::from)?;
        let cortical_channel_index: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, channel).map_err(PyFeagiError::from)?;
        let stage_property_index: PipelineStagePropertyIndex = PyPipelineStagePropertyIndex::try_get_from_py_object(py, pipeline_stage_property_index).map_err(PyFeagiError::from)?;

        // Extract PyObject to Py<PyPipelineStageProperties>
        let stage_py: Py<PyPipelineStageProperties> = stage.extract(py)?;
        let pipeline_stage_properties = extract_pipeline_stage_properties_from_py(py, stage_py).map_err(PyFeagiError::from)?;

        self.inner.sensor_update_stage_segmented_vision_absolute(cortical_group_index, cortical_channel_index,
                                                                 stage_property_index, pipeline_stage_properties)
            .map_err(PyFeagiError::from)?;
        Ok(())
    }

     */

    //endregion


    //endregion


    //region Motors

    pub fn encode_data_from_bytes_to_cache(&mut self, py: Python<'_>) -> PyResult<()> {
        self.inner.motor_update_data_from_bytes().map_err(|err| PyFeagiError::from(err))?;
        Ok(())
    }

    pub fn motor_get_byte_container(&mut self, py: Python<'_>) -> PyResult<PyFeagiByteContainer> {
        let byte_container = self.inner.motor_copy_feagi_byte_container();
        Ok(byte_container.into())
    }

    pub fn motor_set_byte_container(&mut self, py: Python<'_>, feagi_byte_container: PyFeagiByteContainer) -> PyResult<()> {
        self.inner.motor_replace_feagi_byte_container(feagi_byte_container.into());
        Ok(())
    }

    //endregion


    //region Reflexes (premade callbacks)

    pub fn reflex_absolute_gaze_to_absolute_segmented_vision(&mut self, py: Python<'_>, gaze_group: PyObject, gaze_channel: PyObject, segmentation_group: PyObject, segmentation_channel: PyObject) -> PyResult<()> {

        let gaze_group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, gaze_group).map_err(PyFeagiError::from)?;
        let gaze_channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, gaze_channel).map_err(PyFeagiError::from)?;

        let segmentation_group: CorticalGroupIndex = PyCorticalGroupIndex::try_get_from_py_object(py, segmentation_group).map_err(PyFeagiError::from)?;
        let segmentation_channel: CorticalChannelIndex = PyCorticalChannelIndex::try_get_from_py_object(py, segmentation_channel).map_err(PyFeagiError::from)?;

        self.inner.reflex_absolute_gaze_to_absolute_segmented_vision(gaze_group, gaze_channel, segmentation_group, segmentation_channel).map_err(PyFeagiError::from)?;

        Ok(())
    }

    //endregion
}
